{
  "version": 3,
  "sources": ["../src/rsa/safePow.ts", "../src/rsa/KeyPair.ts", "../src/rsa/RSAGenerator.ts", "../src/CryptoRSA.ts", "../src/index.ts"],
  "sourcesContent": ["export default function safePow(a, b, n) {\n    a = BigInt(a);\n    b = BigInt(b);\n    n = BigInt(n);\n\n    a = a % n;\n    let result = 1n;\n    let x = a;\n\n\n    while (b > 0) {\n        let leastSignificantBit = b % 2n;\n        b = b / 2n;\n\n        if (leastSignificantBit === 1n) {\n            result = result * x;\n            result = result % n;\n        }\n\n        x = x * x;\n        x = x % n;\n    }\n\n    return result;\n}", "import safePow from \"./safePow\";\n\nexport default class KeyPair {\n    private readonly p: bigint;\n    private readonly q: bigint;\n    private readonly e: bigint;\n    private readonly N: bigint;\n    private readonly L: bigint;\n    private readonly d: bigint;\n    \n    constructor(p: bigint, q: bigint, e: bigint) {\n        this.p = p;\n        this.q = q;\n        this.e = e;\n        \n        this.N = p * q;\n        this.L = (p - 1n) * (q - 1n);\n        this.d = this.modInverse(e, this.L);\n    }\n    \n    encrypt(message: string) {\n        return safePow(this.stringToBigInt(message), this.e, this.N);\n    }\n    \n    decrypt(message: bigint) {\n        return this.bigIntToString(safePow(message, this.d, this.N));\n    }\n    \n    private stringToBigInt(input: string): bigint {\n        let chars = input.split(\"\");\n        let bigInt = 0n;\n        \n        for (let char of chars) {\n            let charCode = char.charCodeAt(0);\n\n            bigInt = bigInt << 8n;\n            bigInt = bigInt | BigInt(charCode);\n        }\n        \n        return bigInt;\n    }\n    \n    private bigIntToString(input: bigint): string {\n        let string = \"\";\n        \n        while (input !== 0n) {\n            string = String.fromCharCode(Number(input & 255n)) + string;\n            input = input >> 8n;\n        }\n        \n        return string;\n    }\n    \n    private modInverse(a: bigint, n: bigint): bigint {\n        let n0 = n;\n        let y = 0n;\n        let x = 1n;\n\n        if (n == 1n) return 0n;\n\n        while (a > 1n) {\n            let q = a / n;\n            let t = n;\n\n            n = a % n;\n            a = t;\n            t = y;\n\n            y = x - q * t;\n            x = t;\n        }\n\n        if (x < 0) {\n            x = x + n0\n        }\n\n        return x;\n    }\n}", "import KeyPair from \"./KeyPair\";\nimport safePow from \"./safePow\";\n\nexport default abstract class RSAGenerator {\n    private readonly n: number;\n    private readonly e: number;\n    \n    public k: number = 500;\n    public ensureKey: boolean = true;\n    \n    protected abstract randomBit(): boolean;\n    \n    constructor(n: number, e: number) {\n        this.n = n;\n        this.e = e;\n    }\n    \n    async generateKeys() {\n        let p = await this.generateComponent(this.n / 2);\n        let q = await this.generateComponent(this.n - (this.n / 2));\n        \n        if (p < q) {\n            let t = p;\n            p = q;\n            q = t;\n        }\n        \n        return new KeyPair(p, q, BigInt(this.e));\n    }\n    \n    private async generateComponent(length: number, e: bigint = 65537n): Promise<bigint> {\n        let component = e + 1n;\n        \n        while (component % e === 1n) {\n            component = await this.generatePrime(length);\n        }\n        \n        return component;\n    }\n    \n    private async generatePrime(length: number): Promise<bigint> {\n        while (this.ensureKey) {\n            let randomBigint = this.randomBigintFromLength(length, 0b11n);\n            randomBigint = randomBigint | 1n;\n            \n            let result = this.findPrime(length, randomBigint);\n            \n            if (result !== 0n) {\n                return result;\n            }\n            \n            if (!this.ensureKey) {\n                throw new Error(\"No prime after K\");\n            }\n        }\n    }\n    \n    private randomBigintFromLength(n: number, component: bigint = 0n): bigint {\n        let offset = component.toString(2).length;\n        \n        for (let i = 0; i < (n - offset); i++) {\n            component = component << 1n;\n            \n            if (this.randomBit()) {\n                component = component | 1n;\n            }\n        }\n        \n        return component;\n    }\n    \n    private findPrime(n: number, startingNumber: bigint): bigint {\n        let number = startingNumber;\n        \n        let maxK = (n * Math.log(2)) / 2;\n        \n        for (let i = 0; i < maxK; i++) {\n            if (this.checkPrime(number)) {\n                return number;\n            }\n\n            number += 2n;\n        }\n        \n        return 0n;\n    }\n    \n    private checkPrime(n: bigint): boolean {\n        if (n === 2n || n === 3n) {\n            return true;\n        }\n\n        if (n % 2n === 0n || n < 2n) {\n            return false;\n        }\n        \n        for (let i = 2n; i < 1000n; i++) {\n            if (n % i === 0n) {\n                return false;\n            }\n        }\n        \n        return this.millerRabin(n);\n    }\n    \n    private millerRabin(n: bigint): boolean {\n        let s = 0n;\n        let d = n - 1n;\n        \n        while ((d & 1n) === 0n) {\n            d >>= 1n;\n            ++s;\n        }\n        \n        let base = 2n;\n        let x = safePow(base, d, n);\n        \n        if (x === 1n || x === n - 1n) {\n            return true;\n        }\n        \n        for (let i = 0n; i <= s; i++) {\n            x = safePow(x, x, n);\n            \n            if (x === n - 1n) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n}", "import RSAGenerator from \"./rsa/RSAGenerator\";\n\nexport default class CryptoRSA extends RSAGenerator {\n    protected randomBit(): boolean {\n        let i = new Uint8Array(1);\n        crypto.getRandomValues(i);\n        \n        return i[0] % 2 === 0;\n    }\n}", "import CryptoRSA from \"./CryptoRSA\";\n\nasync function main() {\n    let generator = new CryptoRSA(2048, 65537);\n    let keys = await generator.generateKeys();\n    \n    console.log(keys);\n    console.log(keys.encrypt(\"Hello world\"));\n}\n\nmain();\n"],
  "mappings": "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",
  "names": []
}
