{
  "version": 3,
  "sources": ["../dist/mjs/rsa/safePow.js", "../dist/mjs/BinaryHelper.js", "../dist/mjs/rsa/PublicComponent.js", "../dist/mjs/rsa/KeyPair.js", "../dist/mjs/rsa/RSAGenerator.js", "../dist/mjs/SeededRandom.js", "../dist/mjs/SeededRSA.js", "run.ts"],
  "sourcesContent": ["export default function safePow(a, b, n) {\n    a = BigInt(a);\n    b = BigInt(b);\n    n = BigInt(n);\n    a = a % n;\n    let result = 1n;\n    let x = a;\n    while (b > 0) {\n        let leastSignificantBit = b % 2n;\n        b = b / 2n;\n        if (leastSignificantBit === 1n) {\n            result = result * x;\n            result = result % n;\n        }\n        x = x * x;\n        x = x % n;\n    }\n    return result;\n}\n", "export default class BinaryHelper {\n    static bigIntToString(input) {\n        let string = \"\";\n        while (input !== 0n) {\n            string = String.fromCharCode(Number(input & 255n)) + string;\n            input = input >> 8n;\n        }\n        return string;\n    }\n    static stringToBigInt(input) {\n        let chars = input.split(\"\");\n        let bigInt = 0n;\n        for (let char of chars) {\n            let charCode = char.charCodeAt(0);\n            bigInt = bigInt << 8n;\n            bigInt = bigInt | BigInt(charCode);\n        }\n        return bigInt;\n    }\n    static bigIntToBase64(input) {\n        return btoa(BinaryHelper.bigIntToString(input));\n    }\n    static base64toBigInt(input) {\n        return BinaryHelper.stringToBigInt(atob(input));\n    }\n}\n", "import safePow from \"./safePow\";\nimport BinaryHelper from \"../BinaryHelper\";\nexport default class PublicComponent {\n    N;\n    e;\n    constructor(N, e) {\n        this.N = N;\n        this.e = e;\n    }\n    encrypt(message) {\n        let chunks = this.toChunks(message);\n        return chunks.map(chunk => {\n            let binary = safePow(BinaryHelper.stringToBigInt(chunk), this.e, this.N);\n            return BinaryHelper.bigIntToBase64(binary);\n        })\n            .join(\"$\");\n    }\n    checkSignature(message, signature) {\n        let messageChunks = this.toChunks(message);\n        let signatureChunks = signature.split(\"$\");\n        if (messageChunks.length !== signatureChunks.length) {\n            return false;\n        }\n        for (let i = 0; i < messageChunks.length; i++) {\n            let messagePart = messageChunks[i];\n            let signaturePart = signatureChunks[i];\n            let signatureBigInt = BinaryHelper.base64toBigInt(signaturePart);\n            let verifier = safePow(signatureBigInt, this.e, this.N);\n            if (messagePart !== BinaryHelper.bigIntToString(verifier)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    toChunks(string) {\n        let chunkLength = this.N.toString(2).length / 8;\n        let chunks = [];\n        while (string.length > chunkLength) {\n            let chunk = string.slice(0, chunkLength);\n            chunks.push(chunk);\n            string = string.slice(chunkLength);\n        }\n        if (string !== \"\") {\n            chunks.push(string);\n        }\n        return chunks;\n    }\n    toString() {\n        return BinaryHelper.bigIntToBase64(this.N)\n            + \"$\" + BinaryHelper.bigIntToBase64(this.e);\n    }\n    static fromString(string) {\n        let [N, e] = string.split(\"$\");\n        return new PublicComponent(BinaryHelper.base64toBigInt(N), BinaryHelper.base64toBigInt(e));\n    }\n}\n", "import safePow from \"./safePow\";\nimport BinaryHelper from \"../BinaryHelper\";\nimport PublicComponent from \"./PublicComponent\";\nexport default class KeyPair extends PublicComponent {\n    p;\n    q;\n    L;\n    d;\n    constructor(p, q, e) {\n        super(p * q, e);\n        this.p = p;\n        this.q = q;\n        this.L = (p - 1n) * (q - 1n);\n        this.d = this.modInverse(e, this.L);\n    }\n    extractPublicComponent() {\n        return new PublicComponent(this.N, this.e);\n    }\n    decrypt(message) {\n        let chunks = message.split(\"$\");\n        return chunks.map(chunk => {\n            let bigInt = BinaryHelper.base64toBigInt(chunk);\n            return BinaryHelper.bigIntToString(safePow(bigInt, this.d, this.N));\n        })\n            .join(\"\");\n    }\n    sign(message) {\n        let chunks = this.toChunks(message);\n        return chunks.map(chunk => {\n            let bitInt = BinaryHelper.stringToBigInt(chunk);\n            let signature = safePow(bitInt, this.d, this.N);\n            return BinaryHelper.bigIntToBase64(signature);\n        })\n            .join(\"$\");\n    }\n    modInverse(a, n) {\n        let n0 = n;\n        let y = 0n;\n        let x = 1n;\n        if (n == 1n)\n            return 0n;\n        while (a > 1n) {\n            let q = a / n;\n            let t = n;\n            n = a % n;\n            a = t;\n            t = y;\n            y = x - q * t;\n            x = t;\n        }\n        if (x < 0) {\n            x = x + n0;\n        }\n        return x;\n    }\n    toString() {\n        return BinaryHelper.bigIntToBase64(this.p)\n            + \"$\" + BinaryHelper.bigIntToBase64(this.q)\n            + \"$\" + BinaryHelper.bigIntToBase64(this.e);\n    }\n    static fromString(string) {\n        let [p, q, e] = string.split(\"$\");\n        return new KeyPair(BinaryHelper.base64toBigInt(p), BinaryHelper.base64toBigInt(q), BinaryHelper.base64toBigInt(e));\n    }\n}\n", "import KeyPair from \"./KeyPair\";\nimport safePow from \"./safePow\";\nexport default class RSAGenerator {\n    n;\n    e;\n    k = 500;\n    ensureKey = true;\n    constructor(n, e = 65537) {\n        this.n = n;\n        this.e = e;\n    }\n    async generateKeypair() {\n        let p = await this.generateComponent(this.n / 2);\n        let q = await this.generateComponent(this.n - (this.n / 2));\n        if (p < q) {\n            let t = p;\n            p = q;\n            q = t;\n        }\n        return new KeyPair(p, q, BigInt(this.e));\n    }\n    async generateComponent(length, e = 65537n) {\n        let component = e + 1n;\n        while (component % e === 1n) {\n            component = await this.generatePrime(length);\n        }\n        return component;\n    }\n    async generatePrime(length) {\n        while (this.ensureKey) {\n            let randomBigint = this.randomBigintFromLength(length, 3n);\n            randomBigint = randomBigint | 1n;\n            let result = this.findPrime(length, randomBigint);\n            if (result !== 0n) {\n                return result;\n            }\n            if (!this.ensureKey) {\n                throw new Error(\"No prime after K\");\n            }\n        }\n    }\n    randomBigintFromLength(n, component = 0n) {\n        let offset = component.toString(2).length;\n        for (let i = 0; i < (n - offset); i++) {\n            component = component << 1n;\n            if (this.randomBit()) {\n                component = component | 1n;\n            }\n        }\n        return component;\n    }\n    findPrime(n, startingNumber) {\n        let number = startingNumber;\n        let maxK = (n * Math.log(2)) / 2;\n        for (let i = 0; i < maxK; i++) {\n            if (this.checkPrime(number)) {\n                return number;\n            }\n            number += 2n;\n        }\n        return 0n;\n    }\n    checkPrime(n) {\n        if (n === 2n || n === 3n) {\n            return true;\n        }\n        if (n % 2n === 0n || n < 2n) {\n            return false;\n        }\n        for (let i = 2n; i < 1000n; i++) {\n            if (n % i === 0n) {\n                return false;\n            }\n        }\n        return this.millerRabin(n);\n    }\n    millerRabin(n) {\n        let s = 0n;\n        let d = n - 1n;\n        while ((d & 1n) === 0n) {\n            d >>= 1n;\n            ++s;\n        }\n        let base = 2n;\n        let x = safePow(base, d, n);\n        if (x === 1n || x === n - 1n) {\n            return true;\n        }\n        for (let i = 0n; i <= s; i++) {\n            x = safePow(x, x, n);\n            if (x === n - 1n) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "export default class SeededRandom {\n    currentValue;\n    constructor(seed) {\n        this.currentValue = seed;\n    }\n    next() {\n        return this.currentValue = this.currentValue * 16807n % 2147483647n;\n    }\n}\n", "import RSAGenerator from \"./rsa/RSAGenerator\";\nimport SeededRandom from \"./SeededRandom\";\nexport default class SeededRSA extends RSAGenerator {\n    randomGenerator;\n    randomBit() {\n        return this.randomGenerator.next() % 2n === 0n;\n    }\n    async generateSeeded(seed) {\n        this.randomGenerator = new SeededRandom(seed);\n        return super.generateKeypair();\n    }\n}\n", "import { SeededRSA } from \"../dist/mjs\";\n\nlet generator = new SeededRSA(2048);\n\n//@ts-ignore\ndocument.getElementById(\"button\").addEventListener(\"click\", async () => {\n    let keypair = await generator.generateSeeded(123n);\n    console.log(keypair.toString());\n});\n"],
  "mappings": "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",
  "names": []
}
